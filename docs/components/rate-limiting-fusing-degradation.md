# 限流、熔断、降级设计

**限流**是在系统负载能力范围内发现有异常流量请求时主动做出的防御手段，比如碰到单一用户或来源短时间产生大量请求，超过设定阈值后进行降级处理。

**熔断**是系统负载超负荷后被动触发及时降级的保护手段。

**降级**除了通过限流、熔断触发，也可以手动触发。

> 可以参考 Sentinel 的实现进行设计。

## 限流

设计目标：

+ 限流分类
+ 限流指标
+ 指标数据统计
+ 限流策略
+ 限流后请求处理

### 限流分类

从 Sentinel 看，其虽然提供了很多控制规则，不过这些规则仍然分为限流、熔断两类。

限流规则：

+ 流量控制

  提供对资源QPS/并发数两方面的整体流控。

  这个规则个人感觉保证实施的有效性有点困难，系统中一般有很多资源，这么多资源共享系统资源，实际使用时很难确认每个资源应该分配多少系统资源，除非统计线上各个资源被调用的占比，然后根据这个调用占比进行压测，获取每个资源的最大负载进行流控规则设置。

  这种规则有种弊端，某个资源被限流，但是可能系统其实还有余力处理。

  FlowSlot 中实现。

+ **系统自适应保护**

  从系统整体综合 Load、RT、QPS、线程数 几个维度对整个系统进行流控保护，这里的系统应该是单个服务节点，有任意一个维度超过阈值请求就会被降级，相对于流量控制，系统自适应保护规则的资源就是整个系统，这个更实用，且相对更容易实施。

  关于这些指标值的设置（比如RT设置为多少、整体QPS设置为多少），可以压测或者线上通过监控系统获取。

  SystemSlot 中实现。

+ 集群流量控制

  引入集中式的流控节点，对整个集群所有节点进行整体流控。使用相对更麻烦一些，不过没有说明负载对负载均衡的影响，如果不会调整负载均衡，感觉和单机的差别不大。

+ 网关流量控制

  就是将流量控制整合到网关层。

  和服务层 “流量控制” 一样会面临应该分配多少资源的问题。

+ **热点参数限流**

  对资源进行参数级别更细粒度的限流控制。

  这也是一种比较常用的限流规则，可以检测并限制恶意用户的频繁访问。

  ParamFlowSlot 中实现。

+ 黑白名单

  仅仅是针对请求来源（origin 头信息）限制访问。

  AuthoritySlot 中实现。

熔断规则：

+ 熔断降级

### 限流指标

业内限流方案多采用 HPS （Hits Per Second，每秒点击数）或者 RPS（每秒请求数） 作为限流指标。

> HPS RPS 通常是一样的，QPS 侧重每秒完成的查询数量。

### 指标数据统计

很容易想到拦截请求进行统计，可以使用 Filter、Interceptor、AOP，Sentinel 使用了 Interceptor 和 AOP。

> Sentinel 使用 Interceptor 统计、校验**接口**限流指标数据，使用 AOP 实现统计、校验**用户自定义资源**限流指标数据。

指标数据结构：

对接口限流就是统计用户或来源对接口访问次数，统计 `UserId -> ReqeustMethod:APIRoute -> Count`。

TODO。

### 限流策略

同样是在拦截请求时进行校验，

## 熔断

## 手动降级

## Sentinel 整合

主要是配置资源定义和规则管理。

**资源定义**：

可以引入组件自动注册资源（比如 `sentinel-spring-webmvc-adapter`），也可以通过 `@SentinelResource`  注解定义资源 以及定制 异常处理器和 Fallback 实现。

**规则管理**：

线上环境需要引入第三方配置中心，Dashboard 修改规则发送到配置中心，再由配置中心推送到各个 Sentinel 客户端。
但是注意 Dashboard 默认并不支持将规则发送到配置中心，需要用户自行修改。

如果不嫌麻烦、不嫌配置不好看也可以直接通过配置中心修改 Sentinel 规则。

**Sentinel 常用的限流规则**：

个人认为最常用的限流规则是系统自适应限流、热点参数限流。

也可以自定义限流规则，然后通过 SPI 的方式注入到规则校验责任链。

**定制实现**：

+ **接口自定义降级处理**

  使用 @SentinelResource 可以为资源专门定义 blockHandler、fallback 方法，但是使用 SentinelWebInterceptor 发现官网并没有说明应该怎么为每个资源定制降级实现。

  看初始化源码发现降级处理器的设置逻辑：先判断 blockExceptionHandlerOptional 即**自定义的 BlockExceptionHandler** Bean 是否存在，存在就使用自定义的，不存在再看配置文件中有没有配置**阻塞页面**，有的话重定向到阻塞页面，没有的话设置默认的 **DefaultBlockExceptionHandler**，

  即 SentinelWebInterceptor 不支持像 @SentinelResource 那样为每个接口定制降级逻辑。

  那么如何为接口自定义降级？有两种方法：

  + 排除 `sentinel-spring-webmvc-adapter` 依赖在接口上使用 @SentinelResource 并定制降级方法
  + BlockExceptionHandler 接口方法 handle 参数包含  `HttpServletRequest request` 完全可以在 handle() 中从 request 获取 请求方式和路由，进而调用对应的降级处理。

+ **自定义用户黑白名单限流**

  AuthoritySlot 能否用于实现用户黑名单限流。从源码处理流程看也可以，但是不合适，AuthoritySlot 本意是通过黑白名单限制请求来源 APP，AuthorityRule 的成员字段 resource、limitApp、strategy；在请求头 origin 中放用户ID以及在 limitApp 中放被限制的用户ID都不合适，且一个AuthorityRule是针对某个资源（比如某个接口）的，用户黑名单限流规则应该支持针对所有资源。

  所以需要自行实现拓展。

  实现要点：

  + 自定义 ProcessorSlot 以及规则、规则管理器、规则校验器、限流异常，通过Java SPI 加载并注册到 Sentinel 责任链
  + 添加自定义规则配置的动态刷新以及配置到规则实例的转换器
  + 在 `SentinelWebInterceptor` 前面注册一个新的拦截器，用于记录用户上下文信息，用于后面用户黑白名单校验

  代码参考 Git Commit: `feat: 高可用：Sentinel拓展用户黑白单限流规则`。

  

  
